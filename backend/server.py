import os
import random
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import motor.motor_asyncio
import httpx

# --- Configuration ---
app = FastAPI()
client = motor.motor_asyncio.AsyncIOMotorClient(os.environ.get("MONGO_URL", "mongodb://localhost:27017"))
db = client["planmyday"]
venues_collection = db["venues"]

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Models ---
class PlanRequest(BaseModel):
    location: str
    budget: str
    interests: list[str]
    time_of_day: str
    group_size: int

class Venue(BaseModel):
    name: str
    category: str
    # Add other fields as necessary

# --- AI Planner (Now acting as a Fallback Planner) ---
class AIPlanner:
    def __init__(self, db_collection):
        # The emergent_client has been removed as it's not available locally
        self.venues_collection = db_collection

    async def get_weather(self, location: str):
        # This function remains the same
        try:
            async with httpx.AsyncClient() as client:
                weather_response = await client.get(f"https://wttr.in/{location}?format=j1")
                weather_response.raise_for_status()
                weather_data = weather_response.json()
                current_condition = weather_data.get('current_condition', [{}])[0]
                return f"The weather is {current_condition.get('weatherDesc', [{}])[0].get('value', 'unknown')} with a temperature of {current_condition.get('temp_C', 'N/A')}Â°C."
        except Exception:
            return "Could not retrieve weather information."

    async def generate_plan(self, request: PlanRequest):
        # We now directly call the fallback planning method
        print("AI client not available. Using local fallback planner.")
        return await self.fallback_planning(request)

    async def fallback_planning(self, request: PlanRequest):
        weather = await self.get_weather(request.location)
        print(f"Generating fallback plan for {request.location} with weather: {weather}")

        # Fetch venues from the database that match the user's interests
        cursor = self.venues_collection.find({"category": {"$in": request.interests}})
        all_venues = await cursor.to_list(length=100)
        
        if not all_venues:
            return "Could not find any venues matching your interests. Please try different options."

        plan = "Here is a suggested plan based on your preferences (Generated by local planner):\n\n"
        
        # Select 2-3 random venues from the filtered list
        num_activities = min(len(all_venues), random.randint(2, 3))
        selected_venues = random.sample(all_venues, num_activities)

        for i, venue in enumerate(selected_venues, 1):
            plan += f"{i}. **{venue['name']}** ({venue['category']})\n"
            plan += f"   - A great choice for those interested in {venue['category']}.\n\n"
        
        plan += "Enjoy your day!"
        return plan

planner = AIPlanner(venues_collection)

# --- API Endpoints ---
@app.get("/api/health")
def read_root():
    return {"status": "ok"}

@app.get("/api/venues", response_model=list[Venue])
async def get_venues():
    venues = await venues_collection.find().to_list(length=100)
    return [Venue(**v) for v in venues]

@app.post("/api/plan")
async def create_plan(request: PlanRequest):
    try:
        plan_text = await planner.generate_plan(request)
        return {"plan": plan_text}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
